<!-- Interactive labor supply curve -->
<!-- Vibe coded with GPT-5 in Cursor -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Sine Wave</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #controls {
            margin-top: 20px;
        }
        #amplitudeValue {
            font-weight: bold;
            margin-left: 10px;
        }
        /* Slider tick marker support */
        #sliderContainer {
            position: relative;
            display: inline-block;
            width: 600px; /* match canvas width for alignment */
            vertical-align: middle;
        }
        #bSlider {
            width: 100%;
        }
        #bTickMarker {
            position: absolute;
            width: 2px;
            height: 14px;
            background: #222;
            pointer-events: none;
        }
        #bTickLabel {
            position: absolute;
            color: #444;
            font-size: 12px;
            line-height: 1;
            white-space: nowrap;
            text-align: center;
            transform: translateX(-50%);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <h1>Interactive Labor Supply Curve</h1>
    <canvas id="sineCanvas" width="600" height="300" style="border:1px solid #ccc;"></canvas>
    <div id="controls">
        <label for="bSlider">UBI payment b: </label>
        <div id="sliderContainer">
            <input type="range" id="bSlider" min="0" max="20" value="0" step="0.01" list="bTicks">
            <div id="bTickMarker" title="b = C_sub p"></div>
            <div id="bTickLabel">10<br>(subsistence income)</div>
        </div>
        <datalist id="bTicks">
            <option value="10"></option>
        </datalist>
        <span id="bValue">0.00</span>
    </div>
    <script>
        const canvas = document.getElementById('sineCanvas');
        const ctx = canvas.getContext('2d');
        const bSlider = document.getElementById('bSlider');
        const bValue = document.getElementById('bValue');
        const sliderContainer = document.getElementById('sliderContainer');
        const bTickMarker = document.getElementById('bTickMarker');
        const bTickLabel = document.getElementById('bTickLabel');
        const width = canvas.width;
        const height = canvas.height;

        // Position a visible tick at b = C_sub * p (10 by default)
        function updateBThresholdMarker() {
            const C_sub = 10.0, p = 1.0; // keep in sync with drawLaborSupply
            const bTick = C_sub * p;
            const min = parseFloat(bSlider.min);
            const max = parseFloat(bSlider.max);
            const percent = Math.min(1, Math.max(0, (bTick - min) / (max - min)));
            const x = percent * bSlider.clientWidth;
            // Place the marker roughly over the slider track vertically
            const top = bSlider.offsetTop + (bSlider.offsetHeight / 2) - (bTickMarker.offsetHeight / 2);
            bTickMarker.style.left = x + 'px';
            bTickMarker.style.top = top + 'px';
            // Place the label centered under the marker
            const labelTop = bSlider.offsetTop + bSlider.offsetHeight + 8;
            bTickLabel.style.left = x + 'px';
            bTickLabel.style.top = labelTop + 'px';
        }

        function drawAxesFlipped(margin, L_max, LMaxAxis, wMinAxis, wMaxAxis) {
            const left = margin.left;
            const right = margin.right;
            const top = margin.top;
            const bottom = margin.bottom;
            const plotWidth = width - left - right;
            const plotHeight = height - top - bottom;

            ctx.save();
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1.2;
            ctx.font = "12px Arial";
            ctx.fillStyle = '#222';

            // Axes lines (x: L, y: w)
            const xAxisY = top + plotHeight; // bottom of plot (w axis line)
            const yAxisX = left;             // left of plot (L axis line)
            ctx.beginPath();
            // x-axis
            ctx.moveTo(left, xAxisY);
            ctx.lineTo(left + plotWidth, xAxisY);
            // y-axis
            ctx.moveTo(yAxisX, top + plotHeight);
            ctx.lineTo(yAxisX, top);
            ctx.stroke();

            // X ticks (L values at [0, L_max/2, L_max])
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            const xTicks = [0, L_max / 2, L_max];
            for (const tick of xTicks) {
                const x = left + (tick / LMaxAxis) * plotWidth;
                ctx.beginPath();
                ctx.moveTo(x, xAxisY);
                ctx.lineTo(x, xAxisY + 6);
                ctx.stroke();
                ctx.fillText(tick.toString(), x, xAxisY + 8);
            }

            // Y ticks (w values 0..5)
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let w = 0; w <= 5; w++) {
                const y = top + (1 - (w - wMinAxis) / (wMaxAxis - wMinAxis)) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(yAxisX, y);
                ctx.lineTo(yAxisX - 6, y);
                ctx.stroke();
                ctx.fillText(w.toString(), yAxisX - 8, y);
            }

            // Axis labels
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('Labor supplied (L)', left + plotWidth / 2, xAxisY + 26);

            ctx.save();
            ctx.translate(left - 34, top + plotHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText('Wage (w)', 0, 0);
            ctx.restore();

            ctx.restore();
        }
        function drawLaborSupply(b) {
            // labor supply parameters
            const alpha = 1.0;
            const beta = 1.0;
            const C_sub = 10.0;
            const p = 1.0;
            const L_max = 16.0;

            // Plot margins and area
            const margin = { left: 48, right: 16, top: 16, bottom: 40 };
            const left = margin.left;
            const right = margin.right;
            const top = margin.top;
            const bottom = margin.bottom;
            const plotWidth = width - left - right;
            const plotHeight = height - top - bottom;

            // Axis domain for L (x) and w (y)
            const LMinAxis = 0.0, LMaxAxis = L_max + 2.0; // match Python xlim(0, L_max+2)
            const wMinAxis = 0.0, wMaxAxis = 5.0;
            const wMinData = 0.01; // avoid division by zero in formula
            const nPoints = 1000;

            // Prepare data points in w-space
            const ws = [];
            for (let i = 0; i < nPoints; i++) {
                ws.push(wMinData + i * (wMaxAxis - wMinData) / (nPoints - 1));
            }

            // Compute L(w) and apply correction: if L > L_max, set L = 0
            const Ls = ws.map(w => {
                let L = L_max * alpha / (alpha + beta) + beta * (C_sub * p - b) / (w * (alpha + beta));
                if (L > L_max) L = 0; // Python correction: L[L>L_max] = 0
                return L;
            });

            // Clear and draw axes
            ctx.clearRect(0, 0, width, height);
            drawAxesFlipped(margin, L_max, LMaxAxis, wMinAxis, wMaxAxis);

            // Plot curve within bounds (x=L, y=w)
            ctx.beginPath();
            let started = false;
            for (let i = 0; i < nPoints; i++) {
                const L = Ls[i];
                const w = ws[i];
                if (L < LMinAxis) continue; // allow L==0 and up to L_max; L>L_max already clamped to 0
                const x = left + (L - LMinAxis) / (LMaxAxis - LMinAxis) * plotWidth;
                const y = top + (1 - (w - wMinAxis) / (wMaxAxis - wMinAxis)) * plotHeight;
                if (!started) { ctx.moveTo(x, y); started = true; }
                else { ctx.lineTo(x, y); }
            }
            ctx.strokeStyle = '#FF4136';
            ctx.lineWidth = 2;
            ctx.stroke();
            // ensure the threshold marker is positioned correctly after layout
            updateBThresholdMarker();
        }

        bSlider.addEventListener('input', () => {
            const b = parseFloat(bSlider.value);
            bValue.textContent = b.toFixed(2);
            drawLaborSupply(b);
        });
        window.addEventListener('resize', updateBThresholdMarker);
        // Initial sync & draw
        const initialB = parseFloat(bSlider.value);
        bValue.textContent = initialB.toFixed(2);
        drawLaborSupply(initialB);
        // Initial marker position
        updateBThresholdMarker();
    </script>
</body>
</html>
